//
//  GenerateCommand.swift
//  swiftrsrc
//
//  Created by Indragie on 1/31/15.
//  Copyright (c) 2015 Indragie Karunaratne. All rights reserved.
//

import Foundation

private let PathRequirements = "Must be an *.xcassets, *.storyboard, or *.clr path"
private let SourceFileHeader = "// Automatically generated by swiftrsrc. Do not edit.\n\n"

struct Errors {
    static let InvalidInputPath = NSError(
        domain: GenerateCommand.ErrorDomain,
        code: GenerateCommand.ErrorCode.InvalidInputPath.rawValue,
        userInfo: [NSLocalizedDescriptionKey: "Invalid input path. " + PathRequirements]
    )
    static let InvalidOutputPath = NSError(
        domain: GenerateCommand.ErrorDomain,
        code: GenerateCommand.ErrorCode.InvalidOutputPath.rawValue,
        userInfo: [NSLocalizedDescriptionKey: "Invalid output path."]
    )
}

private func generatorForPath(path: String) -> Result<CodeGeneratorType, NSError> {
    var error: NSError?
    if let URL = NSURL.fileURLWithPath(path) {
        if let pathExtension = URL.pathExtension {
            let generator: CodeGeneratorType? = {
                switch pathExtension {
                case "xcassets":
                    return AssetCatalog(URL: URL, error: &error)
                case "storyboard":
                    return Storyboard(URL: URL, error: &error)
                case "clr":
                    return ColorList(URL: URL, error: &error)
                default:
                    return nil
                }
            }()
            if let generator = generator {
                return success(generator)
            }
        }
    }
    return failure(error ?? Errors.InvalidInputPath)
}

private func outputURLForPath(path: String, fileName: String) -> Result<NSURL, NSError> {
    if let URL = NSURL(fileURLWithPath: path) {
        var isDirectory: ObjCBool = false
        if NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) {
            if isDirectory {
                return success(URL.URLByAppendingPathComponent(fileName))
            } else {
                // Overwrite the existing file.
                return success(URL)
            }
        } else {
            // Assume that the path is to a file that needs to be created.
            return success(URL)
        }
    } else {
        return failure(Errors.InvalidOutputPath)
    }
}

private func generateSourceFileContents(generator: CodeGeneratorType, platform: Platform) -> String {
    var src = SourceFileHeader
    switch platform {
    case .iOS:
        src += "import UIKit"
    case .OSX:
        src += "import Cocoa"
    }
    src += "\n\n" + generator.generateCodeForPlatform(platform) + "\n"
    return src
}

struct GenerateCommand: CommandType {
    static let ErrorDomain = "GenerateCommandErrorDomain"
    enum ErrorCode: Int {
        case InvalidInputPath = 1
        case InvalidOutputPath = 2
    }
    
    let verb = "generate"
    let function = "Generate Swift source code"
    
    func run(mode: CommandMode) -> Result<(), CommandantError> {
        return GenerateOptions.evaluate(mode).flatMap { options in
            let result = generatorForPath(options.inputPath).flatMap { generator -> Result<(), NSError> in
                outputURLForPath(options.outputPath, generator.name + ".swift").flatMap {
                    let src = generateSourceFileContents(generator, options.platform)
                    return src.writeToURL($0, atomically: true, encoding: NSUTF8StringEncoding)
                }
            }
            switch result {
            case .Success:
                return success(())
            case .Failure(let boxedError):
                return failure(CommandantError.UsageError(description: boxedError.unbox.localizedDescription))
            }
        }
    }
}

struct GenerateOptions: OptionsType {
    let platform: Platform
    let inputPath: String
    let outputPath: String
    
    static func create(platform: Platform)(inputPath: String)(outputPath: String) -> GenerateOptions {
        return GenerateOptions(platform: platform, inputPath: inputPath, outputPath: outputPath)
    }
    
    static func evaluate(m: CommandMode) -> Result<GenerateOptions, CommandantError> {
        return create
            <*> m <| Option(key: "platform", defaultValue: Platform.iOS, usage: "platform to generate code for. Must be either \"ios\" or \"osx\"")
            <*> m <| Option(usage: "input path to generate code from. " + PathRequirements)
            <*> m <| Option(usage: "output path to write the generated code to. If a directory path is specified, the generated code will be placed in a Swift source code file with the same name as the struct")
    }
}
